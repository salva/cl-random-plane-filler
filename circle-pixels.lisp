(ql:quickload "lisp-magick")
(ql:quickload "matlisp")
(ql:quickload "vecto")

(defpackage #:circle-pixels
  (:use #:cl #:vecto #:matlisp))

(in-package circle-pixels)

(proclaim '(optimize speed))

(defparameter *dilution* 1)

(defconstant %inv-pi (/ 1.0 pi))

(defparameter *rgbk-wheel* '((1 1 1) (1 0 0) (0 1 0) (0 0 1) (0 0 0)))
(defparameter *cmyk-wheel* '((1 1 1) (0 1 1) (1 0 1) (1 1 0) (0 0 0)))
(defparameter *cmy-wheel* '((1 1 1) (0 1 1) (1 0 1) (1 1 0)))
(defparameter *allk-wheel* '((1 1 1) (0 1 1) (1 0 1) (1 1 0) (1 0 0) (0 1 0) (0 0 1) (0 0 0)))
(defparameter *all-wheel* '((1 1 1) (0 1 1) (1 0 1) (1 1 0) (1 0 0) (0 1 0) (0 0 1)))

(defun color-to-matrix-b (color)
  (let ((b (matlisp::zeros '(4 1))))
    (setf (matlisp::ref b 3 0) 1.0)
    (do ((comp color (cdr comp))
         (j 0 (+ j 1)))
        ((null comp) b)
      (setf (matlisp::ref b j 0) (coerce (car comp) 'double-float)))))

(defun wheel-to-matrix-A (wheel)
  (let* ((n-colors (length wheel))
         (A (matlisp::zeros (list 4 n-colors))))
    (do ((color wheel (cdr color))
         (i 0 (+ i 1)))
        ((null color) A)
      (do ((comp (car color) (cdr comp))
           (j 0 (+ j 1)))
          ((null comp))
        ;;(print (list :i i :j j :comp (car comp)))
        (setf (matlisp::ref A j i) (coerce (car comp) 'double-float)))
      (setf (matlisp::ref A 3 i) 1.0))))

(defun decompose-color-with-matrices (A b)
  (let* ((sol (matlisp::gelsy A b))
         (dims (matlisp::dims A))
         (n-colors (cadr dims))
         (negs))
    ;;    (print (list :A A :b b '--> :sol sol))
    (dotimes (j n-colors)
      (when (< (matlisp::ref sol j 0) -0.05)
        (setf negs (cons j negs))))
    (if (null negs) sol
        (let* ((rows (car dims))
               (extra (length negs))
               (A+ (matlisp::zeros (list (+ rows extra) n-colors)))
               (b+ (matlisp::zeros (list (+ rows extra) 1))))
          (dotimes (j rows)
            (setf (matlisp::ref b+ j 0) (matlisp::ref b j 0))
            (dotimes (i n-colors)
              (setf (matlisp::ref A+ j i) (matlisp::ref A j i))))
          (do ((zero negs (cdr zero))
               (j rows (+ j 1)))
              ((null zero))
            (setf (matlisp::ref A+ j (car zero)) 1.0)
            (setf (matlisp::ref b+ j 0) 0.0)
            (dotimes (j 3)
              (setf (matlisp::ref A+ j (car zero)) 0.0)))
          (decompose-color-with-matrices A+ b+)))))

(defun decompose-color (color wheel)
  (let* ((A (wheel-to-matrix-A wheel))
         (b (color-to-matrix-b color))
         (sol (decompose-color-with-matrices A b))
         (n-colors (car (matlisp::dims sol)))
         (result))
    ;; (print (list :n-colors n-colors :sol sol))
    (do ((j (- n-colors 1) (- j 1)))
        ((< j 0) result)
      (setf result (cons (matlisp::ref sol j 0) result)))))
    
(defun draw-pixel (x0 y0 pixel-size color wheel)
  (let* ((radius (* 0.5 pixel-size))
         (ox (+ radius x0))
         (oy (+ radius y0))
         (area-total (* pi radius radius *dilution*))
         (comps (decompose-color color wheel))
         (comps-pairs (sort (cdr (mapcar #'cons comps wheel))
                            #'(lambda (a b) (<= (car a) (car b)))))
         (areas-pairs)
         (acu-area 0))
    (dolist (pair comps-pairs)
      (let ((area (* area-total (car pair))))
        (setf acu-area (+ acu-area (if (< area 0) 0 area)))
        (setf areas-pairs (cons (cons acu-area (cdr pair)) areas-pairs))))
    (dolist (pair areas-pairs)
      (let* ((area (car pair))
             (radius (sqrt (* %inv-pi area)))
             (color (cdr pair)))
        (destructuring-bind (r g b) color
          (set-rgb-fill r g b)
          (centered-circle-path ox oy radius)
          (fill-path)
          ;;(stroke)
          )))))

(defun circletize (file-in file-out &key (pixel-size 32) (zoom 1) (wheel *allk-wheel*))
  (print "loading file")(finish-output)
  (magick:with-magick-wand (wand-in :load file-in)
    (print "drawing image") (finish-output)
    (magick:with-pixel-data (pd-in wand-in)
      (let* ((pixel-size-out (* zoom pixel-size))
             (width  (magick:get-image-width wand-in))
             (height (magick:get-image-height wand-in))
             (width-pixels  (ceiling width pixel-size))
             (height-pixels (ceiling height pixel-size)))
        (with-canvas (:width (* pixel-size-out width-pixels)
                             :height (* pixel-size-out height-pixels))
          (dotimes (y-p height-pixels)
            (dotimes (x-p width-pixels)
              (let* ((x0 (floor (* x-p width) width-pixels))
                     (y0 (floor (* y-p height) height-pixels))
                     (x1 (floor (* (+ x-p 1) width) width-pixels))
                     (y1 (floor (* (+ y-p 1) height) height-pixels))
                     (dx (- x1 x0))
                     (dy (- y1 y0))
                     (source-pixel-area (* dx dy))
                     (inv-source-pixel-area-256 (/ 1.0 256 source-pixel-area))
                     (acu-r 0)
                     (acu-g 0)
                     (acu-b 0))
                (dotimes (x dx)
                  (dotimes (y dy)
                    (multiple-value-bind (r g b) (magick:get-pixel pd-in (+ x0 x) (+ y0 y))
                      (setf acu-r (+ acu-r r))
                      (setf acu-g (+ acu-g g))
                      (setf acu-b (+ acu-b b)))))
                (let ((mean-r (* acu-r inv-source-pixel-area-256))
                      (mean-g (* acu-g inv-source-pixel-area-256))
                      (mean-b (* acu-b inv-source-pixel-area-256)))
                  (draw-pixel (* x-p pixel-size-out)
                              (* (- height-pixels 1 y-p) pixel-size-out)
                              pixel-size-out
                              (list mean-r mean-g mean-b)
                              wheel)))))
          (print "saving image")
          (save-png file-out))))))
